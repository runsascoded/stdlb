#!/usr/bin/env -S uv run --quiet --script
# /// script
# dependencies = []
# ///
"""Generate stdlb/__init__.py from stdlib analysis."""
import sys
from typing import Dict, List, Set

# Version requirements for modules
VERSION_REQUIREMENTS = {
    'graphlib': (3, 9),
    'zoneinfo': (3, 9),
    'tomllib': (3, 11),
}

# Modules that should preserve the module reference (not just import members)
PRESERVE_MODULE = {
    'datetime', 'shlex', 'time', 'glob', 'os', 'sys',
}

# Special handling for certain modules
SPECIAL_ALIASES = {
    'datetime': {
        'dt': 'datetime.datetime',
        'fromtimestamp': 'dt.fromtimestamp',
        'fromisoformat': 'dt.fromisoformat',
    },
}

# Known collisions with __builtins__ that we should preserve
PRESERVE_BUILTINS = {
    'open', 'compile', 'pow', 'copyright', 'BlockingIOError',
    'TimeoutError', 'Warning', 'abs', 'enumerate', 'exit',
    'filter', 'property', 'repr', 'slice', 'str',
}

# Additional preferences for collision resolution
COLLISION_PREFERENCES = {
    'path': 'os.path',  # prefer os.path over sys.path
    'join': 'os.path.join',  # prefer os.path.join over shlex.join
}

# Modules with useful submodules to import
IMPORT_SUBMODULES = {
    'urllib': ['parse', 'request', 'error'],
    'os': ['path'],
    'collections': ['abc'],
    'html': ['parser', 'entities'],
    'http': ['client', 'server', 'cookies'],
    'xml': ['etree'],
}


def generate_header() -> str:
    """Generate file header with docstring."""
    return '''"""Wildcard-import the Python standard library.

This file is auto-generated by scripts/generate_init.py.
Do not edit manually.
"""
import sys
'''


def generate_module_imports(modules: List[str]) -> str:
    """Generate import statements for modules."""
    lines = []

    for module in sorted(modules):
        version_req = VERSION_REQUIREMENTS.get(module)

        if version_req:
            major, minor = version_req
            lines.append(f"if sys.version_info >= ({major}, {minor}):")
            # Import module first to preserve reference
            if module in PRESERVE_MODULE:
                lines.append(f"    import {module} as _module_{module}")
                lines.append(f"    from {module} import *")
                lines.append(f"    {module} = _module_{module}")
            else:
                lines.append(f"    import {module}")
                lines.append(f"    from {module} import *")
            lines.append("")
        else:
            # Import module first to preserve reference
            if module in PRESERVE_MODULE:
                lines.append(f"import {module} as _module_{module}")
                lines.append(f"from {module} import *")
                lines.append(f"{module} = _module_{module}")
            else:
                lines.append(f"import {module}")
                lines.append(f"from {module} import *")

            lines.append("")

    return '\n'.join(lines)


def generate_builtin_preservations(collisions: Dict[str, List[str]]) -> str:
    """Generate code to preserve builtins."""
    lines = []
    lines.append("# Preserve builtins that may be shadowed by module members")
    lines.append("_builtins_dict = __builtins__ if isinstance(__builtins__, dict) else __builtins__.__dict__")

    for name in sorted(PRESERVE_BUILTINS):
        if name in collisions:
            lines.append(f"if '{name}' in _builtins_dict:")
            lines.append(f"    {name} = _builtins_dict['{name}']")

    lines.append("")
    return '\n'.join(lines)


def generate_special_handling() -> str:
    """Generate special handling code."""
    lines = []

    # Handle datetime aliases
    if 'datetime' in SPECIAL_ALIASES:
        lines.append("# Datetime convenience aliases")
        for alias, target in SPECIAL_ALIASES['datetime'].items():
            lines.append(f"{alias} = {target}")
        lines.append("")

    # Handle collision preferences
    if COLLISION_PREFERENCES:
        lines.append("# Collision resolution preferences")
        for name, target in sorted(COLLISION_PREFERENCES.items()):
            lines.append(f"{name} = {target}")
        lines.append("")

    return '\n'.join(lines)


def generate_custom_imports() -> str:
    """Generate custom imports (e.g., cached_property)."""
    return """# Custom implementations
from .cached_property import cached_property

"""


def generate_init_file(modules: List[str], collisions: Dict[str, List[str]]) -> str:
    """Generate complete __init__.py content."""
    parts = [
        generate_header(),
        generate_module_imports(modules),
        generate_builtin_preservations(collisions),
        generate_special_handling(),
        generate_custom_imports(),
    ]

    return '\n'.join(parts)


def main():
    """Main entry point."""
    # For now, hardcode the list based on our discovery
    # In a real implementation, this would read from discover_stdlib.py output
    modules = [
        'abc', 'array', 'ast', 'asyncio', 'base64', 'binascii', 'bisect',
        'calendar', 'cmath', 'code', 'codecs', 'collections', 'configparser',
        'contextlib', 'copy', 'csv', 'dataclasses', 'datetime', 'decimal',
        'difflib', 'enum', 'fnmatch', 'fractions', 'functools', 'glob',
        'graphlib', 'hashlib', 'heapq', 'hmac', 'html', 'http', 'io',
        'itertools', 'json', 'locale', 'logging', 'math', 'mimetypes',
        'numbers', 'operator', 'os', 'pathlib', 'pickle', 'platform',
        'pprint', 'queue', 'random', 're', 'reprlib', 'secrets', 'shelve',
        'shlex', 'shutil', 'signal', 'socket', 'sqlite3', 'statistics',
        'string', 'struct', 'subprocess', 'sys', 'tempfile', 'textwrap',
        'threading', 'time', 'timeit', 'tomllib', 'traceback', 'types',
        'typing', 'unicodedata', 'urllib', 'uuid', 'warnings', 'weakref',
        'xml', 'zipfile', 'zlib', 'zoneinfo',
    ]

    collisions = {
        'BlockingIOError': ['io'],
        'TimeoutError': ['asyncio'],
        'Warning': ['sqlite3'],
        'abs': ['operator'],
        'compile': ['re'],
        'copyright': ['sys'],
        'enumerate': ['threading'],
        'exit': ['sys'],
        'filter': ['fnmatch'],
        'open': ['codecs', 'io', 'os', 'shelve'],
        'pow': ['math', 'operator'],
        'property': ['enum'],
        'repr': ['reprlib'],
        'slice': ['ast'],
        'str': ['locale'],
    }

    content = generate_init_file(modules, collisions)
    print(content)


if __name__ == '__main__':
    main()
